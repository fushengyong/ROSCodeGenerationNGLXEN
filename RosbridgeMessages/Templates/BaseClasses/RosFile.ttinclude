<#@ include file="$(ProjectDir)\Templates\Helpers\YAMLParser.ttinclude" once="true"#>
<#@ include file="MessageField.ttinclude" once="true" #>
<#@ include file="MessageType.ttinclude" once="true" #>

<#@ assembly name="System.Core" #>

<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>

<#+
    public enum ServiceMessageTypeEnum { Not = 0, Request = 1, Response = 2 }

    public abstract class RosFile
    {
        private readonly string[] RosPackageFolderNameArray = { "msg", "srv", "msgs", "srvs" };

        public FileInfo RosFileInfo {get; private set; }
        public DirectoryInfo PackageDirectoryInfo { get; private set; }
        public string FileContent {get; private set; }
        public MessageType Type { get; private set; }

        public RosFile(FileInfo file){
            if(null == file){
                throw new ArgumentNullException(nameof(file));
            }

            if(!file.Exists){
                throw new FileNotFoundException(file.FullName);
            }

            this.RosFileInfo = file;
            this.FileContent = File.ReadAllText(this.RosFileInfo.FullName);
            SetPackageDirectoryInfo();
            string namespaceName = this.PackageDirectoryInfo.Name;
            string className = Path.GetFileNameWithoutExtension(this.RosFileInfo.Name);
            Type = new MessageType(namespaceName, className);
        }

        public RosFile(string fileContent, string className, string namespaceName){
            if(null == fileContent){
                throw new ArgumentNullException(nameof(fileContent));
            }

            if(null == className){
                throw new ArgumentNullException(nameof(className));
            }

            if(null == namespaceName){
                throw new ArgumentNullException(nameof(namespaceName));
            }

            //FileContent can be empty (service with no response)

            if(string.Empty == className){
                throw new ArgumentException("Parameter cannot be empty!", nameof(className));
            }

            if(string.Empty == namespaceName){
                throw new ArgumentException("Parameter cannot be empty!", nameof(namespaceName));
            }

            this.FileContent = fileContent;
            Type = new MessageType(namespaceName, className);
        }

        public override bool Equals(object obj)
        {
            if (obj != null && obj is RosFile){

                RosFile item = obj as RosFile;

                if (item == null)
                {
                    return false;
                }

                return this.Type == item.Type;
            }
            return false;
        }

        protected abstract void ProcessFields();

        private void SetPackageDirectoryInfo(){
            if(RosPackageFolderNameArray.Contains(this.RosFileInfo.Directory.Name)){
                this.PackageDirectoryInfo = this.RosFileInfo.Directory.Parent;
            }
            else
            {                       
                this.PackageDirectoryInfo = this.RosFileInfo.Directory;
            }
        }
    }

    public class MsgFile : RosFile
    {
        private const string HEADER_TYPE_NAME = "Header";
        public const string FILE_EXTENSION = "msg";

        public static readonly Dictionary<string,string> PrimitiveTypeDictionary = new Dictionary<string,string>
        {
            {"float64", "double"},
            {"uint64", "ulong"},
            {"uint32", "uint"},
            {"uint16", "ushort"},
            {"uint8", "byte"},
            {"int64", "long"},
            {"int32", "int"},
            {"int16", "short"},
            {"int8", "sbyte"},
            {"byte", "byte"},
            {"bool", "bool"},
            {"char", "char"},
            {"string", "string"},
            {"float32", "Single"},
            {"time", "Time"},
            {"duration", "Duration"}     
        };

        public static readonly HashSet<MessageType> MessageTypeSet = new HashSet<MessageType>();

        public bool HasHeader { get; private set; }
        public bool IsMeta { get { return DependencySet.Count > 0; } }
        public ServiceMessageTypeEnum ServiceMessageType { get; private set; }
        public HashSet<MessageField> FieldSet { get; private set; }
        public HashSet<MessageType> DependencySet { get; private set; }

        public MsgFile(FileInfo file) : base(file){
            this.FieldSet = new HashSet<MessageField>();
            this.DependencySet = new HashSet<MessageType>();
            ProcessFields();
        }

        public MsgFile(string fileContent, string className, string namespaceValue, ServiceMessageTypeEnum type) : base(fileContent, className, namespaceValue){
            this.ServiceMessageType = type;
            this.FieldSet = new HashSet<MessageField>();
            this.DependencySet = new HashSet<MessageType>();
            ProcessFields();
        }

        protected override void ProcessFields(){
            this.FieldSet = YAMLParser.YAMLStringToMessageFieldSet(this.FileContent);
            
            foreach(MessageField field in this.FieldSet)
            {
                if(!string.IsNullOrEmpty(field.NamespaceName)){
                    DependencySet.Add(new MessageType(field.NamespaceName, field.TypeName));
                }else if(!PrimitiveTypeDictionary.ContainsKey(field.TypeName)){
                    DependencySet.Add(new MessageType(this.Type.NamespaceName, field.TypeName));
                }

                if(field.TypeName == HEADER_TYPE_NAME){
                    HasHeader = true;
                }
            }

            MessageTypeSet.Add(this.Type);
        }
    }

    public class SrvFile : RosFile
    {
        private const string INPUT_OUTPUT_SEPARATOR = "---";
        private const string REQUEST_NAME = "Request";
        private const string RESPONSE_NAME = "Response";
        private const string TYPE_SEPARATOR = "__";

        public const string FILE_EXTENSION = "srv";

        public MsgFile Response { get; private set; }
        public MsgFile Request { get; private set; }

        public SrvFile(FileInfo file) : base(file){
            ProcessFields();
        }

        protected override void ProcessFields(){
            string[] splittedFileContent = this.FileContent.Split(new string[] { INPUT_OUTPUT_SEPARATOR }, StringSplitOptions.None);

            string requestString = splittedFileContent.FirstOrDefault();
            string responseString = splittedFileContent.LastOrDefault();

            if(requestString != null){
                string tempClassName = string.Format("{0}{1}{2}",this.Type.TypeName, TYPE_SEPARATOR, RESPONSE_NAME);
                Request = new MsgFile(requestString, tempClassName, this.Type.NamespaceName, ServiceMessageTypeEnum.Request);
            }

            if(responseString != null){
                string tempClassName = string.Format("{0}{1}{2}",this.Type.TypeName, TYPE_SEPARATOR, REQUEST_NAME);
                Response = new MsgFile(responseString, tempClassName, this.Type.NamespaceName, ServiceMessageTypeEnum.Response);
            }
        }
    }
#>